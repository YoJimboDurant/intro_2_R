# R Command Line
## RGUI
Windows, R runs in a graphical user interface (GUI) environment. This R's GUI, with an R Console open:
![R's console](images/Rconsole.png)

<article>
Figure \ref{fig:RGUI} shows R's GUI, with the R Console. The R Console interprets the 
R commands and provides the output. Commands can be typed in directly, or a whole set
of commands can be run from a script that you can open in the R GUI or load from an external
file.
<\article>

## The R Console
The R Console is the interpreter for R.

- Command can be typed in and ENTER key pressed.
- The interpreter will examine the command and either prompt for more  *+* (continuation prompt) or attempt to execute the command.
- Comments: Any line beginning with *#* is a comment and is ignored. Anything after is ignored until end of line.
- Semicolons can separate commands on same line
- Braces *{* and *}* can group commands together.


## Your first function - help.start()
```{r help.start, eval=FALSE}
help.start()
```
![R help](images/The_R_Language1.png)

## Your second function - help()
```{r help, eval=FALSE}
help("lm")  # inside () is arguments passed to function help
help("help")
?help   # abbriviate the help with ?
help(package="stats") # arguments can be by order or named
```
<article>
We should spend some time talking about function arguments. As you can see by the help page for help, there are several arguments that can passed to the `help` function. If these are passed in order of the function's expected arguments, its, expecting the topic first, then package (which if not specified defaults to NULL), etc. Arguments can be partially matched by title. 

<\article>

## Your third function - help.search()
```{r help.search, eval=FALSE}
help.search("generalized linear model")
```
## RStudio
Integrated Development Environments (IDE's) such as RStudio come with features to make coding and running code easier. RStudio's features  include:

- Window for writing and highlighting code (and identifying errors)
- Window that contains the RConsole interpreter
- Hot keys, word completion, auto-parenthesis
- Show what is available in your environment
- Window to interactively store plots, show files, and show help
- Data importation wizards

## RStudio Desktop
![Rstudio](./images/Rstudio.png)
<article>
Features to note in RStudio:

- RStudio contains 4 main windows. 
- These windows can be adjusted or even repositioned inside the container.
- To open a new code listing, you select File -> New File -> Rscript.
- You can save the file with the extension ".R" so RStudio will know it is an R file next time you open it.
- You can type code into the console, or type it into your Rscript file. Highlight the portion of the code in the Rscript and press <Control> and <Enter> and it will run the highlighted code to the RConsole. 
- RStudio will highlight potential errors in your code as you type (linting)
- Information on the many hot keys and functionality in RStudio can be found at: https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf
- For instance, you can place the cursor anywhere in your Rscript in RStudio and press *<Control>* and *B*, and RStudio will run your code from the start until it reaches the position of the cursor. You can also press *<Alt>* and *-* and RStudio will place and assignment (<-).
<\article>

## Basic Example Operations in Console
```{r}
#Basic Operations
1+1
sqrt(5000)
'Hello World'
1+1; 1-1; 3/3;4*2; 2*pi;pi%%pi
```





## Assignments
Variables are stored in R by _assigning_ them. You can see what variables are in R's memory environment by using the function `objects()`. You can use `<-` or `=` for assignment. 


* Note that R is case sensitive!
* Object names cannot start with a number!
```{r error=TRUE} 
#Variable Assignments
x = 7

x <- 7 #  <- assignment operator 
# (Shortcut key: Alt + -) in Rstudio
print(x)
print(X) # ERROR!

y <- 10-9 ; y #Running variable auto prints
```

<article>
The arrow keys can be useful to scroll through your command history. UP will give you the previous commands, and down will move foward in your command history. That way, if you make a typo, you can correct your previous commands easily. You can also use the command `history()` to see all the past commands you have run.
<\article>

## Objects and Clearing Environment

To see what objects are stored in memory:
```{r}
objects()
```

To clear all objects from memory:
```{r}
rm(list=ls())
```

## Logical Comparisons

To use logical comparisons, use the symbols `<, >, >=, <=, ==, !=, %in%`
```{r logic}
x <- 1
x > 2
x < 0
x >= 4
x <= 5
x == 1
x != 1
```

## Atomic structures
Objects can have classes. Atomic structures are the lowest level of class.
```{r atomic}
#Variable classes
class(x)
x <- 1.7
class(x)
y <- 'Hello World!'
class(y)
z <- TRUE
class(z)
```

## Complex and Raw class

<article>
In addition to the classes above, there are complex number classes and the raw class. Raw classes are used to hold raw bytes. For the most part, beginers will probably not need these classes, but for advanced programming applications, they can be quite useful.}
<\article>

```{r more_class} 
a_complex_number <- 1+0i
class(a_complex_number)
xx <- charToRaw("I am not raw")
xx
class(xx)
rawToChar(xx)
```

# Data Structures
## Numeric Vectors

- Data structures hold data. 
- There are different classes of data structures. 
- Simpliest data structure is a vector.
- All items in vector must have same atomic class.

<article>
The vector is the building block of more complex structures, so understanding their basic operations is essential.
<\article>
```{r vector}
X <- c(10.4, 5.6, 3.1, 6.4, 21.7)   # creates a numeric vector
1/X                                
Y <- 1/X
X**2
# assigns 1/X to Y
summary(Y)
```
<article>
The `c` function is concatnate. It combines individual datum 
into a vector that contains  data. Also note that for the mathmatical functions the 
operations are performed on each datum.
<\article>


## Regular and Random Sequences

- R can be used to create regular sequencies of numbers using \texttt{seq}. 
- Random numbers at created using random number generating functions (e.g. \texttt{rnorm}).

rumbers 
```{r sequences}
#regular sequences
seq(from = -5, to = 5, by = 2)
1:15

# use rnorm (see ?rnorm)
randomNums <- rnorm(1000)
summary(randomNums)
```
<article>
You can find out which distributions are supported by typing ```{r} knitr::inline_expr('?distributions')```. You can control type of random number generation in R, and set random number generator seed numbers  - see `?RNG`.
<\article> 


## Character Vectors
Character vectors behave in a different manner than numeric vectors. 
```{r vector2, error=TRUE}
Stooges <- c("Moe", "Larry", "Curly")    
lastNames <- c("Howard", "Fine", "Howard")
1/Stooges # Error
ThreeStooges <- paste(Stooges, lastNames) 
ThreeStooges # prints
```
<article>

The `paste()` function pastes the contents two vectors together item-by-item. If the vector lengths are different, R will issue a warning, and "recycle" to the top of the shorter vector.
<\article>

## Logical Vectors
 Logical vectors can be created as well, either directly by assignment or evaluating a vector.
```{r vector3}
logicVector1 <- c(TRUE, FALSE, FALSE, TRUE)    
logicVector2 <- c(T,F,F,T) #T or F means TRUE or FALSE
(logicVector3 <- X < 10)
summary(logicVector3)
(logicVector4 <- lastNames == "Howard")
```


## Subsetting Vectors
 Logical vectors are often used to subset other vectors. TRUE values are retained, while FALSE are discarded. Numeric values can also be used to subset vectors.
```{r vector4}
V <- 1:10
V[V<5]
V[V==5]
lastNames[1]
lastNames[c(1,3)]
logicVector1[logicVector1]
```

## Factor Vectors
 Factor variables are used to indicate discrete classification, or grouping. 
```{r vectorfactor}
factorStates <- as.factor(sample(sample(state.abb, 10), 100, 
                                 replace = TRUE))  
factorStates
summary(factorStates)
```

<article>
\begin{warning}
The behavior of the `summary()` and other functions change depending on  the class of the vector. Numeric vector results in a simple numeric summary, while logical vectors give you counts of `TRUE` and `FALSE` in the vector. A summary of a factor vector gives you a count of the factor levels.
\end{warning}
<\article>

## Coercion
- Numbers concatnated together will create a numeric vector
- Charcter strings will create a character vector
- Numeric data and character data concatnation will make a character
- conversion of one type of data into another will:
    + result in either NA (character to number - unless the string is a number)
    + result in a factor level number (if factor)

----
   
```{r dangerfactor}
as.numeric(factorStates)
class(c("One", 2, 3, "four"))
as.numeric(factor(c(10,20,30)))
as.numeric(as.character((factor(c(10,20,30)))))
```

## Vector Manipulations

- You can index a vector and use the assignment to change its value:
```{r vector_manip}
ThreeStooges[2] <- "James Durant"
ThreeStooges
X[X<5] <- 0
X
X[X<5] <- rnorm(100) #warning
X[X>50] <- rnorm(100) 
```

<article>
Note the replacement vector must be either 1 - which replaces all values, or of equal length to the replacement. If the index results in a zero length vector, R will not substitute the values.}
<\article>

## Missing Values

- Missing, not available or unknown values are coded with `NA`.
- `is.na(x)` gives logical vector of length `x` with value of `TRUE` for `NA` values in vector `x`.

```{r nas}
x <- c(1:3,NA)
is.na(x)
x == NA
```


<article>=
\vspace{5mm}
\begin{warning}
`x == NA` will evaluate the following:

- is 1 equal to unknown? R doesn't know!
- is 2 equal to unknown? R doesn't know!
- is 3 equal to unknown? R doesn't know!
- is unknown equal to unknown? R doesn't know!
`is.na(x)` will evaluate each element of vector and see if it is a missing value. So what is evaluated is:

- is 1 an unknown? FALSE
- is 2 an unknown? FALSE
- is 3 an unknown? FALSE
- is unknown an unknown? TRUE
\end{warning}
<\article>

## Setting vector elements to NA
If you have a missing code in your data (e.g. -999), then you will need to set that value to `NA`. To do that, you must pass `is.na` a logical vector. 

```{r makeanna}
mydata <- c( 1, 2.4, pi, 40, -999)
mean(mydata)
is.na(mydata) <- mydata == -999
mean(mydata)
mean(mydata, na.rm=TRUE)
```

R by default will assume you do *NOT* want to drop `NA` values. 

## Not a Number Values

- Results of math computations that are not nubmers are coded as `NaN`.
- `is.nan(x)` gives logical vector of length `x` with value of `r knitr::inline_expr('TRUE')` for `NaN` values.

```{r notanumber}
x[5] <- 0/0
x[6] <- Inf - Inf
is.na(x)
is.nan(x)
```


## Vector Calculations and Concatnation
- You can calculate values using numeric vectors:
```{r vectorcals}
X1 <- c(1,2,3,4,5)
X2 <-c(1,2,3)
X1 + X2
X2 <- c(X2, 4, 5)
X1 + X2
```

<article>
Note the fact that when vector lengths are not the same, R will recycle the shorter vector. It will also issue a warning if the longer vector is not divisible by the shorter vector.
<\article>


# The Matrix


## Matrix Facilities
- A matrix in R is a 2 dimensional vector. 
- There are several operators and functions that will apply only to maticies. 
- A matrix is a expected class of the data argument to simple chi-square tests and Fisher's exact test:

To create a matrix:
```{r theone}
TeaTasting <- matrix(c(3, 1, 1, 3),
       nrow = 2,
       dimnames = list(Guess = c("Milk", "Tea"),
                       Truth = c("Milk", "Tea")))

TeaTasting
```


<article>
The output for the Fisher exact test is:
```{r fisher}
fisher.test(TeaTasting, alternative = "greater")
```
<\article>


## Other Ways to Create Matrix
Other ways to create a matrix are with `rbind` and `cbind`

- `rbind` joins 2 or more vectors by as rows.
- `cbind` joins 2 or more vectors by column.

```{r rbind}
rbind(c(1,2), c(3,4))
cbind(c(1,2), c(3,4))
matrix(c(1,2,3,4), ncol=2)
```

- `matrix` will fill the matix by column unless otherwise told to do so: `matrix (..., byrow=TRUE)`.


# Arrays

## Creating Arrays
Arrays are multiple dimension collection of data enteries.

- All items in array must be in same type
- Arrays are indexed using \texttt{[]} brackets
- Multiple dimensions can be accessed in array

<article>
If you create a 1 dimensional array, it will usually be treated as a vector, see section 5.1 of *An Introduction to R*.
<\article>

## Array Example
To create a 3 by 4 by 2 array:

```{r array1}
set.seed(1)
h <- rnorm(24)
Z <- array(h, dim = c(3,4,2))
```

Alternative approach to creating an array is to change the dim attribute of a vector:

```{r array2}
Z1 <-h
dim(Z1)  <- c(3,4,2)
identical(Z,Z1)
```

<article>
The order of the filling of an array is to fill the first, then increase the index on the second, and finally, when the second dimension is filled, it will move to the next highest dimension.  
<\article>

```{r array3}
q <- 1:24
dim(q) <- c(3,4,2)
print(q)
```

Arrays can be indexed. For instance, to see the observation with index `[1,2,2]`:
```{r array4}
Z[1,2,2]
```
Blanks in an index will select all values. To select all observations with index of 1 in the third position:

```{r array5}
Z[,,1]
```

## Array Example - Mantel-Haenszel test
Example from (Shapiro S, Slone D, Rosenberg L, Kaufman DW, Stolley PD,  Miettinen OS. Oral contraceptive use in relation to myocardial infarction. Lancet 1979;1(8119):743-7. See also Mannocci (2009) Ital J. Public Health. 2009;6(4):338â€“40 http://ijphjournal.it/article/viewFile/5765/5509. Test for association of oral contraceptive Use and myocradial infarction (controling for 5 age groups)

```{r mhtest}
mi_array <-
array(c(4,2,62,224,
        9,12,33,390,
        4,33,26,330,
        6,65,9,362,
        6,93,5,301),
      dim = c(2, 2, 5),
      dimnames = list(
          OC.use = c("Yes", "No"),
          Response = c("MI", "Control"),
          Age.Group = c("25-29", "30-34", "35-39", 
                        "40-44", "45-49")))

mantelhaen.test(mi_array)
```


# Data Frames

# Tibbles

# Functions

# Packages - installation and maintence

## Installing Packages

To install a a package, you will need to run the `install.packages()`. For our demonstrations, you will need the following packages:
```{r, eval=FALSE}
install.packages("Epi")
install.packages("compareGroups")
install.packages("epiR")
install.packages("pander")
install.packages("tidyverse")
```
- Install package downloads the needed code from the CRAN repository into the library directory.
- you only need to use `install.packages()` once per installation to install a package on the system. 
- If you upgrade your R installation, you will need to reinstall or move your library.

## Loading Packages

To make a library available in your current session, use `library()`. 
```{r, eval = FALSE}
library("Epi")
```
- Libraries with functions of the same name will mask the function. R will issue a warning if this occurs.
- You can specify which library with the `::`. For instance, `dplyr::select()`
